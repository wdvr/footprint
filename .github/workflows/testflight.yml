name: Deploy to TestFlight

on:
  # Trigger after CI Pipeline completes successfully on main
  workflow_run:
    workflows: ["CI Pipeline"]
    branches: [main]
    types:
      - completed
  # Manual trigger for emergency deployments
  workflow_dispatch:
    inputs:
      build_number_increment:
        description: 'Increment build number by'
        required: false
        default: '1'
        type: string

concurrency:
  group: testflight-deploy
  cancel-in-progress: false

env:
  SCHEME: 'Footprint'
  PROJECT_PATH: 'ios/Footprint.xcodeproj'

jobs:
  build-and-upload:
    name: Build and Upload to TestFlight
    runs-on: macos-latest
    # Only run if CI passed (or if manually triggered)
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        # For workflow_run, we need to checkout the commit that triggered the workflow
        ref: ${{ github.event.workflow_run.head_sha || github.sha }}

    - name: Select Xcode 26
      run: |
        # Find and select the latest Xcode 26.x
        XCODE_PATH=$(ls -d /Applications/Xcode_26*.app 2>/dev/null | sort -V | tail -1)
        if [ -n "$XCODE_PATH" ]; then
          echo "Found Xcode 26: $XCODE_PATH"
          sudo xcode-select -s "$XCODE_PATH/Contents/Developer"
        else
          echo "ERROR: No Xcode 26.x found in /Applications"
          ls -la /Applications/ | grep -i xcode
          exit 1
        fi

        # Verify
        xcodebuild -version
        xcrun --show-sdk-version --sdk iphoneos

    - name: Install XcodeGen
      run: brew install xcodegen

    - name: Generate Xcode project
      run: |
        cd ios
        xcodegen generate

    - name: Resolve Swift Package Dependencies
      run: |
        xcodebuild -resolvePackageDependencies \
          -project ${{ env.PROJECT_PATH }} \
          -scheme ${{ env.SCHEME }}

    - name: Increment build number
      run: |
        cd ios
        # Get current build number and increment
        CURRENT_BUILD=$(/usr/libexec/PlistBuddy -c "Print :CFBundleVersion" Footprint/Info.plist 2>/dev/null || echo "1")
        NEW_BUILD=$((CURRENT_BUILD + ${{ github.event.inputs.build_number_increment || 1 }}))
        echo "Incrementing build number from $CURRENT_BUILD to $NEW_BUILD"

        # Update Info.plist
        /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $NEW_BUILD" Footprint/Info.plist 2>/dev/null || \
        /usr/libexec/PlistBuddy -c "Add :CFBundleVersion string $NEW_BUILD" Footprint/Info.plist

        # Also update widget if exists
        if [ -f "FootprintWidget/Info.plist" ]; then
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $NEW_BUILD" FootprintWidget/Info.plist 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Add :CFBundleVersion string $NEW_BUILD" FootprintWidget/Info.plist
        fi

    - name: Setup App Store Connect API Key
      run: |
        mkdir -p ~/.private_keys
        echo "${{ secrets.APP_STORE_CONNECT_PRIVATE_KEY }}" | tr -d '\r' > ~/.private_keys/AuthKey_${{ secrets.APP_STORE_CONNECT_KEY_ID }}.p8
        chmod 600 ~/.private_keys/AuthKey_${{ secrets.APP_STORE_CONNECT_KEY_ID }}.p8

    - name: Install certificates
      env:
        DISTRIBUTION_CERTIFICATE_BASE64: ${{ secrets.DISTRIBUTION_CERTIFICATE_BASE64 }}
        DISTRIBUTION_CERTIFICATE_PASSWORD: ${{ secrets.DISTRIBUTION_CERTIFICATE_PASSWORD }}
        KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
      run: |
        # Create temporary keychain
        KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
        security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
        security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

        # Import certificate
        CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12
        echo -n "$DISTRIBUTION_CERTIFICATE_BASE64" | base64 --decode -o $CERTIFICATE_PATH
        security import $CERTIFICATE_PATH -P "$DISTRIBUTION_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
        security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

        # Add to keychain search list
        security list-keychain -d user -s $KEYCHAIN_PATH login.keychain-db

    - name: Archive app
      run: |
        xcodebuild archive \
          -project ${{ env.PROJECT_PATH }} \
          -scheme ${{ env.SCHEME }} \
          -configuration Release \
          -archivePath ~/Export/Footprint.xcarchive \
          -destination 'generic/platform=iOS' \
          -allowProvisioningUpdates \
          -authenticationKeyPath ~/.private_keys/AuthKey_${{ secrets.APP_STORE_CONNECT_KEY_ID }}.p8 \
          -authenticationKeyID ${{ secrets.APP_STORE_CONNECT_KEY_ID }} \
          -authenticationKeyIssuerID ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }} \
          CODE_SIGN_STYLE=Automatic \
          DEVELOPMENT_TEAM=N324UX8D9M

    - name: Create ExportOptions.plist
      run: |
        cat > /tmp/ExportOptions.plist << 'EOF'
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>method</key>
            <string>app-store-connect</string>
            <key>teamID</key>
            <string>N324UX8D9M</string>
            <key>signingStyle</key>
            <string>automatic</string>
            <key>uploadSymbols</key>
            <true/>
            <key>destination</key>
            <string>upload</string>
        </dict>
        </plist>
        EOF

    - name: Export and Upload to TestFlight
      run: |
        xcodebuild -exportArchive \
          -archivePath ~/Export/Footprint.xcarchive \
          -exportPath ~/Export \
          -exportOptionsPlist /tmp/ExportOptions.plist \
          -allowProvisioningUpdates \
          -authenticationKeyPath ~/.private_keys/AuthKey_${{ secrets.APP_STORE_CONNECT_KEY_ID }}.p8 \
          -authenticationKeyID ${{ secrets.APP_STORE_CONNECT_KEY_ID }} \
          -authenticationKeyIssuerID ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}

    - name: Get App Version and Build Number
      id: app_version
      run: |
        VERSION=$(/usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" ios/Footprint/Info.plist)
        BUILD=$(/usr/libexec/PlistBuddy -c "Print :CFBundleVersion" ios/Footprint/Info.plist)
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "build=$BUILD" >> $GITHUB_OUTPUT
        echo "Uploaded version $VERSION ($BUILD)"

    - name: Wait for Build Processing and Distribute to TestFlight
      env:
        APP_STORE_CONNECT_KEY_ID: ${{ secrets.APP_STORE_CONNECT_KEY_ID }}
        APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
      run: |
        # Generate JWT token for App Store Connect API
        generate_jwt() {
          local key_id="$APP_STORE_CONNECT_KEY_ID"
          local issuer_id="$APP_STORE_CONNECT_ISSUER_ID"
          local key_file="$HOME/.private_keys/AuthKey_${key_id}.p8"

          local header=$(echo -n '{"alg":"ES256","kid":"'"$key_id"'","typ":"JWT"}' | base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n')
          local now=$(date +%s)
          local exp=$((now + 1200))
          local payload=$(echo -n '{"iss":"'"$issuer_id"'","iat":'"$now"',"exp":'"$exp"',"aud":"appstoreconnect-v1"}' | base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n')

          local signature=$(echo -n "${header}.${payload}" | openssl dgst -sha256 -sign "$key_file" | base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n')

          echo "${header}.${payload}.${signature}"
        }

        JWT=$(generate_jwt)
        APP_BUNDLE_ID="com.wouterdevriendt.footprint"
        VERSION="${{ steps.app_version.outputs.version }}"
        BUILD="${{ steps.app_version.outputs.build }}"

        echo "Looking for build $VERSION ($BUILD)..."

        # Get the app ID
        APP_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT" \
          "https://api.appstoreconnect.apple.com/v1/apps?filter[bundleId]=$APP_BUNDLE_ID")
        APP_ID=$(echo "$APP_RESPONSE" | python3 -c "import sys,json; print(json.load(sys.stdin)['data'][0]['id'])" 2>/dev/null)

        if [ -z "$APP_ID" ]; then
          echo "Error: Could not find app with bundle ID $APP_BUNDLE_ID"
          exit 1
        fi
        echo "Found app ID: $APP_ID"

        # Wait for the build to appear and be processed (up to 30 minutes)
        MAX_ATTEMPTS=60
        ATTEMPT=0
        BUILD_ID=""

        while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
          ATTEMPT=$((ATTEMPT + 1))
          echo "Checking for build (attempt $ATTEMPT/$MAX_ATTEMPTS)..."

          # Refresh JWT if needed (every 15 minutes)
          if [ $((ATTEMPT % 30)) -eq 0 ]; then
            JWT=$(generate_jwt)
          fi

          # Get builds for this app version
          BUILDS_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT" \
            "https://api.appstoreconnect.apple.com/v1/builds?filter[app]=$APP_ID&filter[version]=$BUILD&include=preReleaseVersion")

          BUILD_ID=$(echo "$BUILDS_RESPONSE" | python3 -c "
        import sys, json
        data = json.load(sys.stdin)
        builds = data.get('data', [])
        for build in builds:
          if build.get('attributes', {}).get('version') == '$BUILD':
            print(build['id'])
            break
        " 2>/dev/null)

          if [ -n "$BUILD_ID" ]; then
            # Check if build is processed
            PROCESSING_STATE=$(echo "$BUILDS_RESPONSE" | python3 -c "
        import sys, json
        data = json.load(sys.stdin)
        for build in data.get('data', []):
          if build['id'] == '$BUILD_ID':
            print(build.get('attributes', {}).get('processingState', 'UNKNOWN'))
            break
        " 2>/dev/null)

            echo "Build $BUILD_ID found, processing state: $PROCESSING_STATE"

            if [ "$PROCESSING_STATE" = "VALID" ]; then
              echo "Build is processed and valid!"
              break
            elif [ "$PROCESSING_STATE" = "INVALID" ]; then
              echo "Error: Build processing failed"
              exit 1
            fi
          fi

          echo "Build not ready yet, waiting 30 seconds..."
          sleep 30
        done

        if [ -z "$BUILD_ID" ]; then
          echo "Error: Build not found after $MAX_ATTEMPTS attempts"
          exit 1
        fi

        # Get beta groups for the app
        echo "Getting TestFlight beta groups..."
        GROUPS_RESPONSE=$(curl -s -H "Authorization: Bearer $JWT" \
          "https://api.appstoreconnect.apple.com/v1/apps/$APP_ID/betaGroups")

        # Add build to all internal beta groups (isInternalGroup = true)
        echo "$GROUPS_RESPONSE" | python3 -c "
        import sys, json
        data = json.load(sys.stdin)
        groups = data.get('data', [])
        for group in groups:
          attrs = group.get('attributes', {})
          if attrs.get('isInternalGroup', False):
            print(f\"{group['id']}|{attrs.get('name', 'Unknown')}\")
        " 2>/dev/null | while IFS='|' read -r GROUP_ID GROUP_NAME; do
          if [ -n "$GROUP_ID" ]; then
            echo "Adding build to internal group: $GROUP_NAME ($GROUP_ID)"
            curl -s -X POST \
              -H "Authorization: Bearer $JWT" \
              -H "Content-Type: application/json" \
              -d "{\"data\":[{\"type\":\"builds\",\"id\":\"$BUILD_ID\"}]}" \
              "https://api.appstoreconnect.apple.com/v1/betaGroups/$GROUP_ID/relationships/builds"
          fi
        done

        # Submit for beta review (for external testers) if there are external groups
        EXTERNAL_GROUPS=$(echo "$GROUPS_RESPONSE" | python3 -c "
        import sys, json
        data = json.load(sys.stdin)
        groups = data.get('data', [])
        external = [g for g in groups if not g.get('attributes', {}).get('isInternalGroup', False)]
        print(len(external))
        " 2>/dev/null)

        if [ "$EXTERNAL_GROUPS" -gt 0 ]; then
          echo "Submitting build for external beta review..."

          # First add beta build localization (required for external testing)
          curl -s -X POST \
            -H "Authorization: Bearer $JWT" \
            -H "Content-Type: application/json" \
            -d "{
              \"data\": {
                \"type\": \"betaBuildLocalizations\",
                \"attributes\": {
                  \"locale\": \"en-US\",
                  \"whatsNew\": \"Bug fixes and improvements.\"
                },
                \"relationships\": {
                  \"build\": {
                    \"data\": {
                      \"type\": \"builds\",
                      \"id\": \"$BUILD_ID\"
                    }
                  }
                }
              }
            }" \
            "https://api.appstoreconnect.apple.com/v1/betaBuildLocalizations"

          # Submit for beta review
          curl -s -X POST \
            -H "Authorization: Bearer $JWT" \
            -H "Content-Type: application/json" \
            -d "{
              \"data\": {
                \"type\": \"betaAppReviewSubmissions\",
                \"relationships\": {
                  \"build\": {
                    \"data\": {
                      \"type\": \"builds\",
                      \"id\": \"$BUILD_ID\"
                    }
                  }
                }
              }
            }" \
            "https://api.appstoreconnect.apple.com/v1/betaAppReviewSubmissions"

          echo "Build submitted for beta review"
        fi

        echo "TestFlight distribution complete!"

    - name: Upload to TestFlight Summary
      run: |
        echo "## TestFlight Upload Summary" >> $GITHUB_STEP_SUMMARY
        echo "- **Scheme**: ${{ env.SCHEME }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Version**: ${{ steps.app_version.outputs.version }} (${{ steps.app_version.outputs.build }})" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit**: ${{ github.event.workflow_run.head_sha || github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Uploaded at**: $(date -u)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Distribution Status" >> $GITHUB_STEP_SUMMARY
        echo "- ✅ Build uploaded to App Store Connect" >> $GITHUB_STEP_SUMMARY
        echo "- ✅ Build distributed to internal TestFlight groups" >> $GITHUB_STEP_SUMMARY
        echo "- ✅ Build submitted for external beta review (if external groups exist)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Check [App Store Connect](https://appstoreconnect.apple.com) for the build status." >> $GITHUB_STEP_SUMMARY

    - name: Cleanup
      if: always()
      run: |
        rm -rf ~/.private_keys
        rm -rf ~/Export
        # Delete temporary keychain
        security delete-keychain $RUNNER_TEMP/app-signing.keychain-db 2>/dev/null || true
