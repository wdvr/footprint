name: Deploy iOS Dev Agent

on:
  workflow_dispatch:
    inputs:
      deploy_infra:
        description: 'Deploy S3 infrastructure'
        type: boolean
        default: true
      deploy_testflight:
        description: 'Deploy to TestFlight'
        type: boolean
        default: true
      tester_email:
        description: 'Tester email'
        type: string
        default: 'wouterdevriendt@gmail.com'

env:
  BUNDLE_ID: com.wouterdevriendt.iosdevagent
  AWS_REGION: eu-west-1
  TEAM_ID: 'N324UX8D9M'

jobs:
  deploy-infra:
    if: inputs.deploy_infra
    runs-on: ubuntu-latest
    steps:
      - name: Create infra files
        run: |
          mkdir -p infra
          cat > infra/package.json << 'EOF'
          {
            "name": "ios-dev-agent-infra",
            "dependencies": {
              "@pulumi/aws": "^6.0.0",
              "@pulumi/pulumi": "^3.0.0"
            }
          }
          EOF

          cat > infra/Pulumi.yaml << 'EOF'
          name: ios-dev-agent-infra
          runtime: nodejs
          EOF

          cat > infra/Pulumi.prod.yaml << 'EOF'
          config:
            aws:region: eu-west-1
            ios-dev-agent-infra:bucketName: iosdevagent-images
          EOF

          cat > infra/index.ts << 'TYPESCRIPT'
          import * as pulumi from "@pulumi/pulumi";
          import * as aws from "@pulumi/aws";

          const config = new pulumi.Config();
          const bucketName = config.get("bucketName") || "iosdevagent-images";

          const bucket = new aws.s3.Bucket("iosdevagent-images", {
              bucket: bucketName,
              tags: { Project: "iOSDevAgent" },
          });

          const bucketPublicAccessBlock = new aws.s3.BucketPublicAccessBlock("public-access", {
              bucket: bucket.id,
              blockPublicAcls: false,
              blockPublicPolicy: false,
              ignorePublicAcls: false,
              restrictPublicBuckets: false,
          });

          new aws.s3.BucketPolicy("policy", {
              bucket: bucket.id,
              policy: bucket.arn.apply(arn => JSON.stringify({
                  Version: "2012-10-17",
                  Statement: [{
                      Effect: "Allow",
                      Principal: "*",
                      Action: "s3:GetObject",
                      Resource: `${arn}/sessions/*`,
                  }],
              })),
          }, { dependsOn: [bucketPublicAccessBlock] });

          const uploadUser = new aws.iam.User("upload-user", { name: "iosdevagent-ios-app" });

          const uploadPolicy = new aws.iam.Policy("upload-policy", {
              policy: bucket.arn.apply(arn => JSON.stringify({
                  Version: "2012-10-17",
                  Statement: [{
                      Effect: "Allow",
                      Action: ["s3:PutObject", "s3:PutObjectAcl"],
                      Resource: `${arn}/sessions/*`,
                  }],
              })),
          });

          new aws.iam.UserPolicyAttachment("upload-attachment", {
              user: uploadUser.name,
              policyArn: uploadPolicy.arn,
          });

          const accessKey = new aws.iam.AccessKey("upload-key", { user: uploadUser.name });

          export const bucketId = bucket.id;
          export const accessKeyId = accessKey.id;
          export const secretAccessKey = pulumi.secret(accessKey.secret);
          TYPESCRIPT

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Pulumi
        uses: pulumi/actions@v5

      - name: Deploy infrastructure
        working-directory: infra
        run: |
          npm install
          pulumi login --local
          pulumi stack init prod 2>/dev/null || pulumi stack select prod
          pulumi up --yes
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          PULUMI_CONFIG_PASSPHRASE: ""

  build-deploy:
    if: inputs.deploy_testflight
    runs-on: macos-15
    steps:
      - name: Create iOS project
        run: |
          mkdir -p ios/iOSDevAgent/App
          mkdir -p ios/iOSDevAgent/Views
          mkdir -p ios/iOSDevAgent/Resources/Assets.xcassets/AppIcon.appiconset

          cat > ios/project.yml << 'YAML'
          name: iOSDevAgent
          options:
            bundleIdPrefix: com.wouterdevriendt
            deploymentTarget:
              iOS: "17.0"
          packages:
            KeychainSwift:
              url: https://github.com/evgenyneu/keychain-swift
              from: 24.0.0
          targets:
            iOSDevAgent:
              type: application
              platform: iOS
              sources: [iOSDevAgent]
              info:
                path: iOSDevAgent/App/Info.plist
                properties:
                  CFBundleDisplayName: iOSDevAgent
                  CFBundleShortVersionString: "1.0.0"
                  CFBundleIconName: AppIcon
                  UILaunchScreen: {}
                  UISupportedInterfaceOrientations:
                    - UIInterfaceOrientationPortrait
                    - UIInterfaceOrientationLandscapeLeft
                    - UIInterfaceOrientationLandscapeRight
                  UISupportedInterfaceOrientations~ipad:
                    - UIInterfaceOrientationPortrait
                    - UIInterfaceOrientationPortraitUpsideDown
                    - UIInterfaceOrientationLandscapeLeft
                    - UIInterfaceOrientationLandscapeRight
                  NSMicrophoneUsageDescription: "iOSDevAgent needs microphone access."
                  NSPhotoLibraryUsageDescription: "iOSDevAgent needs photo library access."
                  NSCameraUsageDescription: "iOSDevAgent needs camera access."
              settings:
                base:
                  PRODUCT_BUNDLE_IDENTIFIER: com.wouterdevriendt.iosdevagent
                  MARKETING_VERSION: "1.0.0"
                  ASSETCATALOG_COMPILER_APPICON_NAME: AppIcon
              dependencies:
                - package: KeychainSwift
          YAML

          cat > ios/iOSDevAgent/App/Info.plist << 'PLIST'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>CFBundleDisplayName</key>
              <string>iOSDevAgent</string>
              <key>CFBundleShortVersionString</key>
              <string>1.0.0</string>
              <key>CFBundleVersion</key>
              <string>1</string>
              <key>CFBundleIconName</key>
              <string>AppIcon</string>
              <key>UILaunchScreen</key>
              <dict/>
              <key>UISupportedInterfaceOrientations</key>
              <array>
                  <string>UIInterfaceOrientationPortrait</string>
                  <string>UIInterfaceOrientationLandscapeLeft</string>
                  <string>UIInterfaceOrientationLandscapeRight</string>
              </array>
              <key>UISupportedInterfaceOrientations~ipad</key>
              <array>
                  <string>UIInterfaceOrientationPortrait</string>
                  <string>UIInterfaceOrientationPortraitUpsideDown</string>
                  <string>UIInterfaceOrientationLandscapeLeft</string>
                  <string>UIInterfaceOrientationLandscapeRight</string>
              </array>
              <key>NSMicrophoneUsageDescription</key>
              <string>iOSDevAgent needs microphone access.</string>
              <key>NSPhotoLibraryUsageDescription</key>
              <string>iOSDevAgent needs photo library access.</string>
              <key>NSCameraUsageDescription</key>
              <string>iOSDevAgent needs camera access.</string>
          </dict>
          </plist>
          PLIST

          # Create app icon asset catalog with Contents.json
          cat > ios/iOSDevAgent/Resources/Assets.xcassets/Contents.json << 'JSON'
          {
            "info" : {
              "author" : "xcode",
              "version" : 1
            }
          }
          JSON

          cat > ios/iOSDevAgent/Resources/Assets.xcassets/AppIcon.appiconset/Contents.json << 'JSON'
          {
            "images" : [
              {
                "filename" : "icon-1024.png",
                "idiom" : "universal",
                "platform" : "ios",
                "size" : "1024x1024"
              }
            ],
            "info" : {
              "author" : "xcode",
              "version" : 1
            }
          }
          JSON

          # Install Pillow for icon generation
          pip3 install --break-system-packages Pillow

          # Generate a simple app icon using Python (blue gradient with waveform symbol idea)
          python3 << 'PYTHON'
          from PIL import Image, ImageDraw
          import math

          size = 1024
          img = Image.new('RGB', (size, size), '#007AFF')
          draw = ImageDraw.Draw(img)

          # Create gradient background
          for y in range(size):
              r = int(0 + (50 * y / size))
              g = int(122 - (30 * y / size))
              b = int(255 - (50 * y / size))
              draw.line([(0, y), (size, y)], fill=(r, g, b))

          # Draw waveform lines
          center_y = size // 2
          line_width = 40
          gap = 60
          num_lines = 7
          start_x = (size - (num_lines * gap)) // 2

          heights = [200, 350, 280, 400, 280, 350, 200]
          for i, h in enumerate(heights):
              x = start_x + i * gap
              y1 = center_y - h // 2
              y2 = center_y + h // 2
              draw.rounded_rectangle(
                  [(x, y1), (x + line_width, y2)],
                  radius=line_width // 2,
                  fill='white'
              )

          img.save('ios/iOSDevAgent/Resources/Assets.xcassets/AppIcon.appiconset/icon-1024.png')
          print("App icon created")
          PYTHON

          cat > ios/iOSDevAgent/App/iOSDevAgentApp.swift << 'SWIFT'
          import SwiftUI

          @main
          struct iOSDevAgentApp: App {
              var body: some Scene {
                  WindowGroup {
                      ContentView()
                  }
              }
          }
          SWIFT

          cat > ios/iOSDevAgent/Views/ContentView.swift << 'SWIFT'
          import SwiftUI

          struct ContentView: View {
              @State private var selectedRepo = "trivit-ios"
              let repos = ["trivit-ios", "snow", "footprint"]

              var body: some View {
                  NavigationStack {
                      VStack(spacing: 20) {
                          Image(systemName: "waveform.circle.fill")
                              .font(.system(size: 80))
                              .foregroundStyle(.blue)

                          Text("iOS Dev Agent")
                              .font(.title)
                              .fontWeight(.bold)

                          Text("Voice feedback for Claude agents")
                              .foregroundStyle(.secondary)

                          Picker("Repository", selection: $selectedRepo) {
                              ForEach(repos, id: \.self) { repo in
                                  Text(repo).tag(repo)
                              }
                          }
                          .pickerStyle(.segmented)
                          .padding()

                          Button(action: {}) {
                              Label("Record Feedback", systemImage: "mic.fill")
                                  .font(.headline)
                                  .frame(maxWidth: .infinity)
                                  .padding()
                                  .background(.blue)
                                  .foregroundColor(.white)
                                  .clipShape(RoundedRectangle(cornerRadius: 12))
                          }
                          .padding(.horizontal)

                          Spacer()
                      }
                      .padding()
                      .navigationTitle("iOSDevAgent")
                  }
              }
          }
          SWIFT

      - name: Select Xcode
        run: |
          XCODE_PATH=$(ls -d /Applications/Xcode_16*.app 2>/dev/null | sort -V | tail -1)
          if [ -z "$XCODE_PATH" ]; then
            XCODE_PATH="/Applications/Xcode.app"
          fi
          echo "Using Xcode: $XCODE_PATH"
          sudo xcode-select -s "$XCODE_PATH/Contents/Developer"
          xcodebuild -version

      - name: Install XcodeGen
        run: brew install xcodegen

      - name: Generate project
        run: cd ios && xcodegen generate

      - name: Setup App Store Connect API Key
        run: |
          mkdir -p $RUNNER_TEMP/private_keys
          echo "${{ secrets.APP_STORE_CONNECT_PRIVATE_KEY }}" | tr -d '\r' > $RUNNER_TEMP/private_keys/AuthKey_${{ secrets.APP_STORE_CONNECT_KEY_ID }}.p8
          chmod 600 $RUNNER_TEMP/private_keys/AuthKey_${{ secrets.APP_STORE_CONNECT_KEY_ID }}.p8

      - name: Install certificates
        env:
          DISTRIBUTION_CERTIFICATE_BASE64: ${{ secrets.DISTRIBUTION_CERTIFICATE_BASE64 }}
          DISTRIBUTION_CERTIFICATE_PASSWORD: ${{ secrets.DISTRIBUTION_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          set -euo pipefail

          if [ -z "${DISTRIBUTION_CERTIFICATE_BASE64:-}" ]; then
            echo "::warning::DISTRIBUTION_CERTIFICATE_BASE64 not provided - will rely on automatic signing"
            exit 0
          fi
          if [ -z "${DISTRIBUTION_CERTIFICATE_PASSWORD:-}" ]; then
            echo "::warning::DISTRIBUTION_CERTIFICATE_PASSWORD not provided - skipping certificate installation"
            exit 0
          fi
          if [ -z "${KEYCHAIN_PASSWORD:-}" ]; then
            KEYCHAIN_PASSWORD=$(openssl rand -base64 32)
          fi

          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12

          echo "Creating keychain..."
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          echo "Decoding certificate..."
          echo -n "$DISTRIBUTION_CERTIFICATE_BASE64" | base64 --decode > "$CERTIFICATE_PATH"
          echo "Certificate decoded: $(wc -c < "$CERTIFICATE_PATH") bytes"

          echo "Importing certificate..."
          security import "$CERTIFICATE_PATH" -P "$DISTRIBUTION_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"

          echo "Setting key partition list..."
          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          echo "Configuring keychain search list..."
          security list-keychain -d user -s "$KEYCHAIN_PATH" login.keychain-db

          echo "Certificate installation complete"

      - name: Resolve Swift Package Dependencies
        run: |
          cd ios
          xcodebuild -resolvePackageDependencies \
            -project iOSDevAgent.xcodeproj \
            -scheme iOSDevAgent

      - name: Calculate build number
        id: version
        run: |
          BUILD=$(date +%Y%m%d%H%M)
          VERSION="1.0.0"
          cd ios
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $BUILD" iOSDevAgent/App/Info.plist
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "build=$BUILD" >> $GITHUB_OUTPUT
          echo "Building version $VERSION ($BUILD)"

      - name: Archive app
        run: |
          cd ios
          xcodebuild archive \
            -project iOSDevAgent.xcodeproj \
            -scheme iOSDevAgent \
            -configuration Release \
            -archivePath $RUNNER_TEMP/Export/App.xcarchive \
            -destination 'generic/platform=iOS' \
            -allowProvisioningUpdates \
            -authenticationKeyPath $RUNNER_TEMP/private_keys/AuthKey_${{ secrets.APP_STORE_CONNECT_KEY_ID }}.p8 \
            -authenticationKeyID ${{ secrets.APP_STORE_CONNECT_KEY_ID }} \
            -authenticationKeyIssuerID ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }} \
            CODE_SIGN_STYLE=Automatic \
            DEVELOPMENT_TEAM=${{ env.TEAM_ID }}

      - name: Create ExportOptions.plist
        run: |
          cat > /tmp/ExportOptions.plist << EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>method</key>
              <string>app-store-connect</string>
              <key>teamID</key>
              <string>${{ env.TEAM_ID }}</string>
              <key>signingStyle</key>
              <string>automatic</string>
              <key>uploadSymbols</key>
              <true/>
              <key>destination</key>
              <string>export</string>
          </dict>
          </plist>
          EOF

      - name: Export IPA
        run: |
          xcodebuild -exportArchive \
            -archivePath $RUNNER_TEMP/Export/App.xcarchive \
            -exportPath $RUNNER_TEMP/Export \
            -exportOptionsPlist /tmp/ExportOptions.plist \
            -allowProvisioningUpdates \
            -authenticationKeyPath $RUNNER_TEMP/private_keys/AuthKey_${{ secrets.APP_STORE_CONNECT_KEY_ID }}.p8 \
            -authenticationKeyID ${{ secrets.APP_STORE_CONNECT_KEY_ID }} \
            -authenticationKeyIssuerID ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}

      - name: Ensure app exists in App Store Connect
        env:
          APP_STORE_CONNECT_KEY_ID: ${{ secrets.APP_STORE_CONNECT_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
          RUNNER_TEMP: ${{ runner.temp }}
        run: |
          pip3 install --break-system-packages PyJWT cryptography

          python3 << 'PYTHON'
          import jwt
          import time
          import os
          import json
          import urllib.request
          import urllib.error

          key_id = os.environ['APP_STORE_CONNECT_KEY_ID']
          issuer_id = os.environ['APP_STORE_CONNECT_ISSUER_ID']
          key_path = f"{os.environ['RUNNER_TEMP']}/private_keys/AuthKey_{key_id}.p8"
          team_id = "N324UX8D9M"
          bundle_id = "com.wouterdevriendt.iosdevagent"
          app_name = "iOS Dev Agent"

          # Generate JWT
          with open(key_path, 'r') as f:
              private_key = f.read()

          token = jwt.encode(
              {
                  'iss': issuer_id,
                  'iat': int(time.time()),
                  'exp': int(time.time()) + 1200,
                  'aud': 'appstoreconnect-v1'
              },
              private_key,
              algorithm='ES256',
              headers={'kid': key_id}
          )

          headers = {
              'Authorization': f'Bearer {token}',
              'Content-Type': 'application/json'
          }

          def api_request(method, url, data=None):
              req = urllib.request.Request(url, method=method, headers=headers)
              if data:
                  req.data = json.dumps(data).encode()
              try:
                  with urllib.request.urlopen(req) as resp:
                      return json.loads(resp.read().decode())
              except urllib.error.HTTPError as e:
                  error_body = e.read().decode() if e.fp else ''
                  print(f"HTTP {e.code}: {error_body}")
                  return None

          # List all apps to debug
          print("Listing all apps in account...")
          all_apps = api_request('GET', 'https://api.appstoreconnect.apple.com/v1/apps?limit=50')
          if all_apps and all_apps.get('data'):
              for app in all_apps['data']:
                  attrs = app.get('attributes', {})
                  print(f"  - {attrs.get('bundleId')}: {attrs.get('name')}")
          else:
              print("  No apps found or unable to list apps")

          # Check if app exists
          print(f"\nChecking if app {bundle_id} exists...")
          apps = api_request('GET', f'https://api.appstoreconnect.apple.com/v1/apps?filter[bundleId]={bundle_id}')
          if apps and apps.get('data'):
              print(f"App already exists: {apps['data'][0]['id']}")
          else:
              print("App not found, creating...")

              # First create the bundle ID in the developer portal
              print("Step 1: Creating bundle ID...")
              bundle_data = {
                  'data': {
                      'type': 'bundleIds',
                      'attributes': {
                          'identifier': bundle_id,
                          'name': app_name.replace(' ', ''),
                          'platform': 'IOS'
                      }
                  }
              }
              bundle_result = api_request('POST', 'https://api.appstoreconnect.apple.com/v1/bundleIds', bundle_data)
              if bundle_result:
                  bundle_id_resource = bundle_result['data']['id']
                  print(f"Bundle ID created: {bundle_id_resource}")
              else:
                  # Try to find existing bundle ID
                  existing = api_request('GET', f'https://api.appstoreconnect.apple.com/v1/bundleIds?filter[identifier]={bundle_id}')
                  if existing and existing.get('data'):
                      bundle_id_resource = existing['data'][0]['id']
                      print(f"Using existing bundle ID: {bundle_id_resource}")
                  else:
                      print("Failed to create or find bundle ID")
                      exit(1)

              # Create the app in App Store Connect
              print("Step 2: Creating app in App Store Connect...")
              app_data = {
                  'data': {
                      'type': 'apps',
                      'attributes': {
                          'name': app_name,
                          'primaryLocale': 'en-US',
                          'sku': 'iosdevagent-2026',
                          'bundleId': bundle_id
                      },
                      'relationships': {
                          'bundleId': {
                              'data': {
                                  'type': 'bundleIds',
                                  'id': bundle_id_resource
                              }
                          }
                      }
                  }
              }
              app_result = api_request('POST', 'https://api.appstoreconnect.apple.com/v1/apps', app_data)
              if app_result:
                  print(f"App created: {app_result['data']['id']}")
              else:
                  print("ERROR: Failed to create app via API.")
              print("")
              print("Please create the app manually in App Store Connect:")
              print("1. Go to https://appstoreconnect.apple.com")
              print("2. Click 'My Apps' > '+' > 'New App'")
              print(f"3. Select bundle ID: {bundle_id}")
              print(f"4. Name: {app_name}")
              print("5. SKU: iosdevagent")
              print("6. Primary Language: English")
              print("")
              print("After creating the app, re-run this workflow.")
              exit(1)

          PYTHON

      - name: Upload to App Store Connect
        env:
          API_PRIVATE_KEYS_DIR: ${{ runner.temp }}/private_keys
        run: |
          IPA_PATH=$(find $RUNNER_TEMP/Export -name "*.ipa" | head -1)
          echo "Uploading $IPA_PATH to App Store Connect..."
          xcrun altool --upload-app \
            --type ios \
            --file "$IPA_PATH" \
            --apiKey "${{ secrets.APP_STORE_CONNECT_KEY_ID }}" \
            --apiIssuer "${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}"

      - name: Install PyJWT
        run: pip3 install --break-system-packages PyJWT cryptography

      - name: Wait for processing & distribute
        env:
          APP_STORE_CONNECT_KEY_ID: ${{ secrets.APP_STORE_CONNECT_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
          RUNNER_TEMP: ${{ runner.temp }}
        run: |
          JWT=$(python3 -c "import jwt,time,os;k=os.environ['APP_STORE_CONNECT_KEY_ID'];i=os.environ['APP_STORE_CONNECT_ISSUER_ID'];t=os.environ['RUNNER_TEMP'];print(jwt.encode({'iss':i,'iat':int(time.time()),'exp':int(time.time())+1200,'aud':'appstoreconnect-v1'},open(f'{t}/private_keys/AuthKey_{k}.p8').read(),algorithm='ES256',headers={'kid':k}))")

          BUILD="${{ steps.version.outputs.build }}"

          # Get app ID
          APP_RESPONSE=$(curl -g -s -H "Authorization: Bearer $JWT" \
            "https://api.appstoreconnect.apple.com/v1/apps?filter[bundleId]=${{ env.BUNDLE_ID }}")
          APP_ID=$(echo "$APP_RESPONSE" | python3 -c "import sys,json; print(json.load(sys.stdin)['data'][0]['id'])" 2>/dev/null)
          echo "App ID: $APP_ID"

          # Wait for build to be processed
          echo "Waiting for build $BUILD to be processed..."
          for i in {1..40}; do
            BUILDS_RESPONSE=$(curl -g -s -H "Authorization: Bearer $JWT" \
              "https://api.appstoreconnect.apple.com/v1/builds?filter[app]=$APP_ID&filter[version]=$BUILD")

            BUILD_ID=$(echo "$BUILDS_RESPONSE" | python3 -c "
          import sys, json
          data = json.load(sys.stdin)
          for build in data.get('data', []):
            if build.get('attributes', {}).get('version') == '$BUILD':
              print(build['id'])
              break
          " 2>/dev/null)

            if [ -n "$BUILD_ID" ]; then
              STATE=$(echo "$BUILDS_RESPONSE" | python3 -c "
          import sys, json
          for build in json.load(sys.stdin).get('data', []):
            if build['id'] == '$BUILD_ID':
              print(build.get('attributes', {}).get('processingState', 'UNKNOWN'))
          " 2>/dev/null)

              echo "Build $BUILD_ID state: $STATE"
              if [ "$STATE" = "VALID" ]; then
                break
              fi
            fi
            echo "Waiting... (attempt $i/40)"
            sleep 30
          done

          if [ -z "$BUILD_ID" ]; then
            echo "Build not found after waiting"
            exit 1
          fi

          # Set export compliance
          curl -g -s -X PATCH \
            -H "Authorization: Bearer $JWT" \
            -H "Content-Type: application/json" \
            -d "{\"data\":{\"type\":\"builds\",\"id\":\"$BUILD_ID\",\"attributes\":{\"usesNonExemptEncryption\":false}}}" \
            "https://api.appstoreconnect.apple.com/v1/builds/$BUILD_ID"

          # Add to internal beta groups
          GROUPS_RESPONSE=$(curl -g -s -H "Authorization: Bearer $JWT" \
            "https://api.appstoreconnect.apple.com/v1/apps/$APP_ID/betaGroups")

          echo "$GROUPS_RESPONSE" | python3 -c "
          import sys, json
          for group in json.load(sys.stdin).get('data', []):
            if group.get('attributes', {}).get('isInternalGroup', False):
              print(group['id'])
          " 2>/dev/null | while read -r GROUP_ID; do
            echo "Adding build to internal group: $GROUP_ID"
            curl -g -s -X POST \
              -H "Authorization: Bearer $JWT" \
              -H "Content-Type: application/json" \
              -d "{\"data\":[{\"type\":\"builds\",\"id\":\"$BUILD_ID\"}]}" \
              "https://api.appstoreconnect.apple.com/v1/betaGroups/$GROUP_ID/relationships/builds"
          done

          echo "Internal TestFlight distribution complete!"

      - name: Summary
        run: |
          echo "## iOS Dev Agent TestFlight Build" >> $GITHUB_STEP_SUMMARY
          echo "- **Bundle ID**: ${{ env.BUNDLE_ID }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ steps.version.outputs.version }} (${{ steps.version.outputs.build }})" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: Distributed to internal testers" >> $GITHUB_STEP_SUMMARY

      - name: Cleanup
        if: always()
        run: |
          rm -rf $RUNNER_TEMP/private_keys $RUNNER_TEMP/Export
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db 2>/dev/null || true
