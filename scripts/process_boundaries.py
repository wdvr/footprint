#!/usr/bin/env python3
"""Download and process country boundary data from Natural Earth.

This script downloads country boundaries and processes them for use in the iOS app.
Natural Earth provides free, public domain map data.

Usage:
    cd backend && uv run python ../scripts/process_boundaries.py
"""

import json
import zipfile
from io import BytesIO
from pathlib import Path

import httpx
from shapely.geometry import mapping, shape

# Natural Earth 110m (low resolution, good for mobile)
NATURAL_EARTH_URL = (
    "https://naciscdn.org/naturalearth/110m/cultural/" "ne_110m_admin_0_countries.zip"
)

# Output directory
SCRIPT_DIR = Path(__file__).parent
PROJECT_ROOT = SCRIPT_DIR.parent
DATA_DIR = PROJECT_ROOT / "data" / "boundaries"
IOS_DATA_DIR = PROJECT_ROOT / "ios" / "Footprint" / "Resources" / "GeoData"


def download_natural_earth() -> bytes:
    """Download Natural Earth country boundaries."""
    print(f"Downloading from {NATURAL_EARTH_URL}...")
    response = httpx.get(NATURAL_EARTH_URL, follow_redirects=True, timeout=60)
    response.raise_for_status()
    print(f"Downloaded {len(response.content) / 1024:.1f} KB")
    return response.content


def extract_shapefile(zip_content: bytes) -> dict:
    """Extract GeoJSON from shapefile zip."""
    import fiona

    with zipfile.ZipFile(BytesIO(zip_content)) as zf:
        shp_files = [f for f in zf.namelist() if f.endswith(".shp")]
        if not shp_files:
            raise ValueError("No .shp file found in zip")

        import tempfile

        with tempfile.TemporaryDirectory() as tmpdir:
            zf.extractall(tmpdir)
            shp_path = Path(tmpdir) / shp_files[0]

            features = []
            with fiona.open(shp_path) as src:
                for feature in src:
                    features.append(feature)

            return {"type": "FeatureCollection", "features": features}


def simplify_geometry(geom: dict, tolerance: float = 0.1) -> dict:
    """Simplify geometry to reduce file size."""
    shapely_geom = shape(geom)
    simplified = shapely_geom.simplify(tolerance, preserve_topology=True)
    return mapping(simplified)


def process_countries(geojson: dict) -> dict:
    """Process countries and extract relevant properties."""
    processed_features = []

    for feature in geojson["features"]:
        props = feature.get("properties", {})

        iso_code = props.get("ISO_A2") or props.get("ISO_A2_EH")
        if iso_code in (None, "-99", "-1"):
            iso_code = props.get("ADM0_A3", "")[:2] if props.get("ADM0_A3") else None

        if not iso_code or iso_code in ("-99", "-1"):
            print(f"  Skipping: {props.get('NAME', 'Unknown')} (no ISO code)")
            continue

        name = props.get("NAME") or props.get("ADMIN") or "Unknown"

        simplified_geom = simplify_geometry(feature["geometry"], tolerance=0.05)

        processed_features.append(
            {
                "type": "Feature",
                "properties": {
                    "iso_code": iso_code,
                    "name": name,
                    "continent": props.get("CONTINENT", ""),
                    "region": props.get("REGION_UN", ""),
                    "subregion": props.get("SUBREGION", ""),
                },
                "geometry": simplified_geom,
            }
        )

    print(f"Processed {len(processed_features)} countries")
    return {"type": "FeatureCollection", "features": processed_features}


def save_geojson(data: dict, path: Path) -> None:
    """Save GeoJSON to file."""
    path.parent.mkdir(parents=True, exist_ok=True)
    with open(path, "w") as f:
        json.dump(data, f, separators=(",", ":"))
    size_kb = path.stat().st_size / 1024
    print(f"Saved {path.name}: {size_kb:.1f} KB")


def create_swift_country_mapping(geojson: dict, output_path: Path) -> None:
    """Create a Swift file with country code to name mapping."""
    countries = []
    for feature in geojson["features"]:
        props = feature["properties"]
        countries.append(
            {
                "code": props["iso_code"],
                "name": props["name"],
                "continent": props["continent"],
                "region": props["region"],
            }
        )

    countries.sort(key=lambda x: x["name"])

    swift_code = """// Auto-generated country data with boundary information
// Generated by scripts/process_boundaries.py

import Foundation

struct CountryInfo: Codable, Identifiable {
    let code: String
    let name: String
    let continent: String
    let region: String

    var id: String { code }
}

// Countries with boundary data available
let countriesWithBoundaries: [CountryInfo] = [
"""

    for country in countries:
        swift_code += f'    CountryInfo(code: "{country["code"]}", name: "{country["name"]}", continent: "{country["continent"]}", region: "{country["region"]}"),\n'

    swift_code += "]\n"

    output_path.parent.mkdir(parents=True, exist_ok=True)
    with open(output_path, "w") as f:
        f.write(swift_code)
    print(f"Created Swift country mapping: {output_path}")


def main():
    """Main function to download and process boundary data."""
    print("=" * 60)
    print("Footprint Boundary Data Processor")
    print("=" * 60)

    try:
        import fiona  # noqa: F401
    except ImportError:
        print("\nInstalling fiona for shapefile processing...")
        import subprocess

        subprocess.check_call(["uv", "pip", "install", "fiona"])

    zip_content = download_natural_earth()

    print("\nExtracting shapefile...")
    raw_geojson = extract_shapefile(zip_content)
    print(f"Found {len(raw_geojson['features'])} features")

    print("\nProcessing countries...")
    processed = process_countries(raw_geojson)

    print("\nSaving files...")
    save_geojson(processed, DATA_DIR / "countries.geojson")

    IOS_DATA_DIR.mkdir(parents=True, exist_ok=True)
    save_geojson(processed, IOS_DATA_DIR / "countries.geojson")

    swift_path = (
        PROJECT_ROOT / "ios" / "Footprint" / "Generated" / "CountryBoundaries.swift"
    )
    create_swift_country_mapping(processed, swift_path)

    print("\n" + "=" * 60)
    print("Done! Boundary data is ready for use.")
    print("=" * 60)


if __name__ == "__main__":
    main()
